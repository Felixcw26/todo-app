import curses
import random
import sys
from time import sleep
from wcwidth import wcswidth
from core.date_type import Date

class Palette:
    """Definiert Farbpaar-IDs und Style-Konstanten f√ºr curses."""

    COLORS = {
        "GOLD": 178,
        "BRONZE": 136,
        "IVORY": 230,
        "GRAY": 244,
        "RED": 124,
        "GREEN": 107,
        "BLUE": 110,
        "WHITE": 231,
        "YELLOW": 220
    }

    STYLES = {
        "BOLD": curses.A_BOLD,
        "ITALIC": getattr(curses, "A_ITALIC", 0),
        "DIM": curses.A_DIM,
        "UNDERLINE": curses.A_UNDERLINE,
        "REVERSE": curses.A_REVERSE,
        "NORMAL": curses.A_NORMAL,
    }

    SYMBOLS = {
        "CORNER_LEFT_TOP": "‚ïî",
        "CORNER_RIGHT_TOP": "‚ïó",
        "CORNER_LEFT_BOTTOM": "‚ïö",
        "CORNER_RIGHT_BOTTOM": "‚ïù",
        "EDGE_HORIZONTAL": "‚ïê",
        "EDGE_VERTICAL": "‚ïë",
        "BRANCHING_LEFT": "‚ï†",
        "BRANCHING_RIGHT": "‚ï£",
        "BRANCHING_TOP": "‚ï¶",
        "BRANCHING_BOTTOM": "‚ï©",
        "BRANCHING_CROSS": "‚ï¨",
        "CANDLE" : "üïØÔ∏è",
        "GEAR" : "‚öôÔ∏è",
        "BOOK" : "üìñ",
        "ATTENTION" : "‚ö†Ô∏è",
        "HOOK" : "‚úîÔ∏è",
        "PEN" : "‚úíÔ∏è",
        "BOOKS" : "üìö",
        "TEMPEL" : "üèõÔ∏è",
        "DOCTOR_HAT" : "üéì",
        "HOURGLASS" : "‚è≥",
        "HOME" : "üè†",
        "MAIN" : "üìú",
        "GLASS": "üîç",
        "CLIP": "üìé",
        "WRITING": "üìù",
        "POINT_TRIANGLE" : "‚ñ∏",
        "RIGHT_ARROW" : "‚Üí",
        "LEFT_ARROW" : "‚Üê",
        "POINT_DOT" : "‚Ä¢",
        "POINT_SQUARE" : "‚ãÖ",
        "LONG_RIGHT_ARROW" : "‚ü∂",
        "LONG_LEFT_ARROW" : "‚üµ",
        "BACKSPACE" : "‚å´"
        
    }

    @classmethod
    def init_colors(cls):
        curses.start_color()
        curses.use_default_colors()
        for i, (_, color) in enumerate(cls.COLORS.items(), start=1):
            curses.init_pair(i, color, -1)

    @classmethod
    def color(cls, name):
        index = list(cls.COLORS.keys()).index(name) + 1
        return curses.color_pair(index)


class DarkAcademiaConsole:
    """Dark-Academia-Style Console ‚Äì kompatibel mit curses oder Standard-Terminal."""

    curses_mode = False
    stdscr = None

    def __init__(self, palette: Palette, width: int = 60):
        self.palette = palette
        self.width = width
        self.quotes = [
            "üïØÔ∏è  ‚ÄûNichts Gro√ües ist je ohne Leidenschaft entstanden.‚Äú ‚Äì Hegel",
            "üìñ  ‚ÄûDas Denken ist das Selbstgespr√§ch der Seele.‚Äú ‚Äì Platon",
            "üèõÔ∏è  ‚ÄûIn der Stille w√§chst das Wahre.‚Äú ‚Äì Dag Hammarskj√∂ld",
            "‚úíÔ∏è  ‚ÄûNicht weil es schwer ist, wagen wir es nicht, sondern weil wir es nicht wagen, ist es schwer.‚Äú ‚Äì Seneca",
            "üï∞Ô∏è  ‚ÄûIch habe keine Zeit, mich zu beeilen.‚Äú ‚Äì Igor Strawinsky",
            "‚öôÔ∏è  ‚ÄûDisziplin ist Freiheit.‚Äú ‚Äì Jocko Willink",
            "üìö  ‚ÄûWer das Warum seines Lebens kennt, ertr√§gt fast jedes Wie.‚Äú ‚Äì Nietzschee",
            "üèõÔ∏è  ‚ÄûPhilosophie ist ein stilles Gespr√§ch mit der Ewigkeit.‚Äú",
            "üïØÔ∏è  ‚ÄûDer Tag geh√∂rt dem, der ihn bewusst beginnt.‚Äú",
            "üìñ  ‚ÄûZwischen Ordnung und Chaos wohnt die Sch√∂pfung.‚Äú‚Äú",
            "ü™∂  ‚ÄûEin Gedanke ist eine Aufgabe, die noch nicht geschrieben wurde.‚Äú‚Äú",
            "‚è≥  ‚ÄûDie Zeit, die du dir nimmst, ist keine verlorene Zeit.‚Äú ‚Äì Saint-Exup√©ryy",
            "üìö  ‚ÄûWissenschaft ohne Philosophie ist blind, Philosophie ohne Wissenschaft ist leer.‚Äú‚Äú",
            "üïØÔ∏è  ‚ÄûRuhe ist die h√∂chste Form der St√§rke.‚Äú ‚Äì Schiller",
            "üèõÔ∏è  ‚ÄûAlles, was wir sehen, ist nur ein Schatten dessen, was wir nicht sehen.‚Äú ‚Äì Platon",
            "‚úíÔ∏è  ‚ÄûVerstehen hei√üt, den Schatten in der Tiefe zu erkennen, nicht das Licht an der Oberfl√§che.‚Äú",
            "üìñ  ‚ÄûDer Mensch ist das Wesen, das Ordnung sucht ‚Äì und Bedeutung darin findet.‚Äú‚Äú",
            "‚öôÔ∏è  ‚ÄûArbeit ist Gebet, wenn sie mit Hingabe geschieht.‚Äú",
            "üïØÔ∏è  ‚ÄûIm Rhythmus der Arbeit liegt der Sinn des Lebens.‚Äú",
            "üèõÔ∏è  ‚ÄûWir leben in Fragmenten, aber denken im Ganzen.‚Äú ‚Äì Novalis",
            "üìö  ‚ÄûDas Sch√∂nste, was wir erleben k√∂nnen, ist das Geheimnisvolle.‚Äú ‚Äì Einsteinn",
            "‚úíÔ∏è  ‚ÄûOrdnung ist die Freude der Vernunft, aber Unordnung die Wonne der Fantasie.‚Äú ‚Äì Paul Claudel",
            "üï∞Ô∏è  ‚ÄûDie Zukunft geh√∂rt denen, die sich heute darauf vorbereiten.‚Äú ‚Äì Malcolm X",
            "üìñ  ‚ÄûWer die Stille meistert, hat das Denken verstanden.‚Äú‚Äú",
            "üïØÔ∏è  ‚ÄûZwischen Geist und Handlung liegt die Verantwortung.‚Äú",
            "üèõÔ∏è  ‚ÄûWissen verpflichtet ‚Äì vor allem den, der versteht.‚Äú",
            "üìö  ‚ÄûDu bist, was du ordnest.‚Äú‚Äú",
            "‚úíÔ∏è  ‚ÄûIn der Konzentration liegt die Freiheit.‚Äú",
            "üïØÔ∏è  ‚ÄûEin strukturierter Tag ist kein K√§fig, sondern eine B√ºhne.‚Äú",
            "‚öôÔ∏è  ‚ÄûPerfektion ist nicht das Ziel, sondern das Nebenprodukt der Hingabe.‚Äú",
        ]

    def _center_line(self, text: str = "", padding: int = 2) -> str:
        """Zentrierte Zeile mit R√§ndern, ohne Zeilenumbruch."""
        s = self.palette.SYMBOLS
        text_width = wcswidth(text)
        spaces = self.width - text_width + padding
        left = spaces // 2
        right = spaces - left
        return f"{s['EDGE_VERTICAL']}{' ' * left}{text}{' ' * right}{s['EDGE_VERTICAL']}"

    def header(self, title: str, compact: bool = False):
        """Gibt Header-Zeilen als segmentierte Struktur zur√ºck (farbkompatibel f√ºr curses)."""
        s = self.palette.SYMBOLS
        lines = []
        horizontal = s["EDGE_HORIZONTAL"] * (self.width + 2)

        # Rahmen oben ‚Äì komplett Ivory
        lines.append([(f"{s['CORNER_LEFT_TOP']}{horizontal}{s['CORNER_RIGHT_TOP']}", "IVORY", None)])

        if (self.width - len("üìñ ToDo-App") + 2) % 2 == 0:
            padding_right = padding_left =  (self.width - len("üìñ ToDo-App") + 2) // 2
        else:
            padding_right = ((self.width - len("üìñ ToDo-App") + 2) // 2) + 1
            padding_left = (self.width - len("üìñ ToDo-App") + 2) // 2
        
        if (self.width - len(title) + 2) % 2 == 0:
            padding_title_right = padding_title_left = (self.width - len(title) + 2) // 2
        else: 
            padding_title_right = ((self.width - len(title) + 2) // 2) + 1
            padding_title_left = (self.width - len(title) + 2) // 2
        # Zwischenzeilen
        if not compact:
            lines.append([(self._center_line(), "IVORY", None)])
            lines.append([
                ("‚ïë", "IVORY", None),
                (" " * 2, "IVORY", None),
                (str(Date.today()), "GOLD", "BOLD"),
                (" " * (padding_left - 2 - len(str(Date.today()))), "IVORY", None),
                ("üìñ ", "GOLD", None),
                ("ToDo-App", "WHITE", "BOLD"),
                (" " * padding_right, "IVORY", None),
                ("‚ïë", "IVORY", None)
            ])
            lines.append([
                ("‚ïë", "IVORY", None),
                (" " * padding_title_left, "IVORY", None),
                (title, "WHITE", "BOLD"),
                (" " * padding_title_right, "IVORY", None),
                ("‚ïë", "IVORY", None)
            ])
            lines.append([(self._center_line(), "IVORY", None)])
        else:
            lines.append([
                ("‚ïë", "IVORY", None),
                (" " * padding_left, "IVORY", None),
                ("üìñ ", "GOLD", None),
                ("ToDo-App", "WHITE", "BOLD"),
                (" " * padding_right, "IVORY", None),
                ("‚ïë", "IVORY", None)
            ])
            lines.append([
                ("‚ïë", "IVORY", None),
                (" " * padding_title_left, "IVORY", None),
                (title, "WHITE", "BOLD"),
                (" " * padding_title_right, "IVORY", None),
                ("‚ïë", "IVORY", None)
            ])

        return lines


    def footer(self, controls: list[str]) -> list[list[tuple[str, str, str]]]:
        """
        Gibt Footer-Zeilen segmentiert zur√ºck:
        - Rahmen und Linien: Ivory
        - Steuerungstexte (controls): Wei√ü (BOLD)
        """
        s = self.palette.SYMBOLS
        lines = []
        horizontal = s["EDGE_HORIZONTAL"] * (self.width + 2)

        # Mittlere Steuerungszeile
        text = "  ".join(controls)
        padding = (self.width - len(text) + 2) // 2
        if (self.width - len(text) + 2) % 2 == 0:
            padding_right = padding_left = (self.width - len(text) + 2) // 2
        else:
            padding_right = (self.width - len(text) + 2) // 2
            padding_left = ((self.width - len(text) + 2) // 2) + 1
        lines.append([
            (s["EDGE_VERTICAL"], "IVORY", None),
            (" " * padding_right, "IVORY", None),
            (text, "WHITE", "BOLD"),
            (" " *(padding_left), "IVORY", None),
            (s["EDGE_VERTICAL"], "IVORY", None),
        ])

        # Unterer Abschlussrahmen
        lines.append([(f"{s['CORNER_LEFT_BOTTOM']}{horizontal}{s['CORNER_RIGHT_BOTTOM']}", "IVORY", None)])

        return lines
    
    # -------------------------------------------------------------------------
    # Misc
    # -------------------------------------------------------------------------
    @staticmethod
    def clear(stdscr):
        """Gesamten Bildschirm l√∂schen (curses-kompatibel)."""
        stdscr.erase()
        stdscr.refresh()

    @staticmethod
    def clear_current_line(stdscr, y=None):
        """Aktuelle oder bestimmte Zeile l√∂schen."""
        if y is None:
            y, _ = stdscr.getyx()
        stdscr.move(y, 0)
        stdscr.clrtoeol()
        stdscr.refresh()

    @staticmethod
    def erase_last_line(stdscr):
        """Vorherige Zeile l√∂schen."""
        y, _ = stdscr.getyx()
        if y > 0:
            stdscr.move(y - 1, 0)
            stdscr.clrtoeol()
        stdscr.refresh()

    @staticmethod
    def pause(seconds: float = 1.0):
        sleep(seconds)

    @staticmethod
    def typewriter(text, delay=0.04):
        for char in text:
            sys.stdout.write(char)
            sys.stdout.flush()
            sleep(delay)
        print()

    def quote(self):
        return random.choice(self.quotes)